<!DOCTYPE html>
<html lang="en">

<!-- TODO -->
<!-- - process input control image to canny
- modify run stable diffusion to support controlnet -->


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>control.net</title>

    <style>
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            padding: 30px;
        }

        a {
            text-decoration: none;
            color: #4A90E2;
        }

        h1 {
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 20px;
        }

        #mybox {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 50%;
            margin: 0 auto;
        }

        #promptText,
        #stepRange,
        #btnRunNet,
        #conditioningScale,
        #guidanceRange {
            font-size: 18px;
            width: 100%;
        }

        #result {
            font-size: 48px;
        }

        #time {
            font-size: 16px;
            color: grey;
        }

        canvas {
            margin-top: 20px;
            border: 1px solid #000;
        }

        label {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        #sliderValue {
            margin-right: 10px;/
        }
    </style>

    <script type="module">
        import ClipTokenizer from 'https://softwired.nyc3.cdn.digitaloceanspaces.com/sd/clip_tokenizer.js';
        window.clipTokenizer = new ClipTokenizer();
    </script>
    <script src="./f16_to_f32.js"></script>
    <script src="./net.js"></script>
    <script async src="https://docs.opencv.org/master/opencv.js"></script>
</head>

<body>
    <h1 id="wgpuError" style="display: none; color: red;">WebGPU is not supported in this browser</h1>
    <h1 id="sdTitle">ControlNet on WebGPU</h1>
    <div id="mybox">
        <label>
            Constraint:
            <select id="constraintSelect">
                <option value="default">Select a Constraint</option>
                <option value="canedge">Canny Edge Map</option>
                <option value="scribble">Scribble</option>
            </select>
        </label>

        <label>
            Prompt:
            <input id="promptText" type="text" placeholder="Enter your prompt here" value="a painting of a cat"
                disabled>
        </label>

        <label>
            Steps: <span id="stepValue">3</span>
            <input id="stepRange" type="range" min="1" max="20" value="3" step="1" disabled>
        </label>

        <label>
            Guidance: <span id="guidanceValue">7.5</span>
            <input id="guidanceRange" type="range" min="3" max="15" value="7.5" step="0.1" disabled>
        </label>

        <label>
            Conditioning scale: <span id="conditioningScaleValue">1.0</span>
            <input id="conditioningScale" type="range" min="0" max="2" value="1.0" step="0.1" disabled>
        </label>

        <label>
            Constraint image:
            <input id="imageUpload" hidden type="file" accept="image/*" onchange="previewImage()">
            <button id="clear" hidden>Clear Scribble</button>
        </label>

        <canvas id="inputCanvas" width="512" height="512"></canvas>

        <input id="btnRunNet" type="button" value="Run" disabled>

        <div id="divModelDl" style="display: flex; align-items: center; width: 100%; gap: 10px;">
            <span id="modelDlTitle">Downloading model</span>
            <progress id="modelDlProgressBar" value="0" max="100" style="flex-grow: 1;"></progress>
            <span id="modelDlProgressValue"></span>
        </div>

        <div id="divStepProgress" style="display: none; align-items: center; width: 100%; gap: 10px;">
            <progress id="progressBar" value="0" max="100" style="flex-grow: 1;"></progress>
            <span id="progressFraction"></span>
        </div>
    </div>
    <canvas id="controlCanvas" width="512" height="512"></canvas>
    <canvas id="canvas" width="512" height="512"></canvas>

    <script>
        let nets, metadata, safetensorsName, metadataLength;

        function previewImage() {
            var fileInput = document.getElementById('imageUpload');
            if (fileInput.files && fileInput.files[0]) {
                var oFReader = new FileReader();
                oFReader.readAsDataURL(fileInput.files[0]);

                oFReader.onload = function (oFREvent) {
                    var img = new Image();
                    img.onload = function () {
                        var canvas = document.getElementById('inputCanvas');
                        var ctx = canvas.getContext('2d');

                        // Resize the canvas to match the image size
                        canvas.width = img.width;
                        canvas.height = img.height;

                        // Draw the image onto the canvas
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = oFREvent.target.result;
                };
            }
        }

        function initDb() {
            return new Promise((resolve, reject) => {
                let db;
                const request = indexedDB.open('tinydb', 1);
                request.onerror = (event) => {
                    console.error('Database error:', event.target.error);
                    resolve(null);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Db initialized.");
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('tensors')) {
                        db.createObjectStore('tensors', { keyPath: 'id' });
                    }
                };
            });
        }

        function saveTensorToDb(db, id, tensor) {
            return new Promise((resolve, reject) => {
                if (db == null) {
                    resolve(null);
                }

                const transaction = db.transaction(['tensors'], 'readwrite');
                const store = transaction.objectStore('tensors');
                const request = store.put({ id: id, content: tensor });

                transaction.onabort = (event) => {
                    console.log("Transaction error while saving tensor: " + event.target.error);
                    resolve(null);
                };

                request.onsuccess = () => {
                    console.log('Tensor saved successfully.');
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Tensor save failed:', event.target.error);
                    resolve(null);
                };
            });
        }

        function readTensorFromDb(db, id) {
            return new Promise((resolve, reject) => {
                if (db == null) {
                    resolve(null);
                }

                const transaction = db.transaction(['tensors'], 'readonly');
                const store = transaction.objectStore('tensors');
                const request = store.get(id);

                transaction.onabort = (event) => {
                    console.log("Transaction error while reading tensor: " + event.target.error);
                    resolve(null);
                };

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    if (result) {
                        console.log("Cache hit: " + id);
                        resolve(result);
                    } else {
                        console.log("Cache miss: " + id);
                        resolve(null);
                    }
                };

                request.onerror = (event) => {
                    console.error('Tensor retrieve failed: ', event.target.error);
                    resolve(null);
                };
            });
        }

        const getDevice = async () => {
            const adapter = await navigator.gpu.requestAdapter();
            const requiredLimits = {};
            const maxBufferSizeInSDModel = 4294967292; // ~4GB
            requiredLimits.maxStorageBufferBindingSize = maxBufferSizeInSDModel;
            requiredLimits.maxBufferSize = maxBufferSizeInSDModel;

            return await adapter.requestDevice({
                requiredLimits,
                requiredFeatures: ["shader-f16"],
            });
        };

        const getMetadataLength = async (file) => {
            return await readRangeFromFile(file, 0, 8).then((result) => {
                return Number(new DataView(result.buffer).getBigUint64(0, true));
            });
        };

        const getMetadata = async (file, N) => {
            return await readRangeFromFile(file, 8, 8 + N).then((result) => {
                return JSON.parse(new TextDecoder("utf-8").decode(result));
            });
        };

        const timer = async (func, label = "") => {
            const start = performance.now();
            const out = await func();
            const delta = (performance.now() - start).toFixed(1)
            console.log(`${delta} ms ${label}`);
            return out;
        };

        const getProgressDlForPart = async (part, progressCallback) => {
            const response = await fetch(part);
            const contentLength = response.headers.get('content-length');
            const total = parseInt(contentLength, 10);

            const res = new Response(new ReadableStream({
                async start(controller) {
                    const reader = response.body.getReader();
                    for (; ;) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        progressCallback(part, value.byteLength, total);
                        controller.enqueue(value);
                    }

                    controller.close();
                },
            }));

            return res.arrayBuffer();
        };

        const progressCallback = (part, loaded, total) => {
            totalLoaded += loaded;

            if (!partSize[part]) {
                totalSize += total;
                partSize[part] = true;
            }

            progress(totalLoaded, totalSize);
        };

        function getControlTensor(modelVariant) {
            const canvas = document.getElementById('inputCanvas');

            if (modelVariant == "canedge") {
                return getCannyControl(canvas);
            }
            else if (modelVariant == "scribble") {
                return getScribbleControl(canvas);
            }
        }

        function convertToCanny(canvas, cannyHigh, cannyLow) {

            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            let src = cv.matFromImageData(imgData);
            let dst = new cv.Mat();
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.Canny(src, dst, cannyLow, cannyHigh, 3, false);
            cv.imshow('controlCanvas', dst);
            return dst;
        }

        function getCannyControl(canvas) {
            // TODO: move canny parameters to gui
            let canny_high = 200
            let canny_low = 100

            let control_canny = convertToCanny(canvas, canny_high, canny_low)

            const rows = control_canny.rows;
            const cols = control_canny.cols;

            let control_tensor = new Float32Array(3 * 512 * 512);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let dstIndex = i * cols + j;
                    let value = control_canny.ucharPtr(i, j)[0] / 255.0;
                    control_tensor[0 * 512 * 512 + dstIndex] = value; 
                    control_tensor[1 * 512 * 512 + dstIndex] = value;
                    control_tensor[2 * 512 * 512 + dstIndex] = value;
                }
            }
            return control_tensor;
        }

        function convertToScribble(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // hack: fill rgb channels with alpha channel
            for (let i = 0; i < imgData.data.length; i += 4) {
                imgData.data[i] = imgData.data[i + 3];
                imgData.data[i + 1] = imgData.data[i + 3];
                imgData.data[i + 2] = imgData.data[i + 3];
            }
            let src = cv.matFromImageData(imgData);
            let dst = new cv.Mat();
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, dst, 128, 255, cv.THRESH_BINARY);
            cv.imshow('controlCanvas', dst);
            return dst;
        }

        function getScribbleControl(canvas) {
            let control_scribble = convertToScribble(canvas)

            let control_tensor = new Float32Array(3 * 512 * 512);
            let rows = control_scribble.rows;
            let cols = control_scribble.cols;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let dstIndex = i * cols + j;
                    let value = control_scribble.ucharPtr(i, j)[0] / 255.0;
                    control_tensor[0 * 512 * 512 + dstIndex] = value; 
                    control_tensor[1 * 512 * 512 + dstIndex] = value;
                    control_tensor[2 * 512 * 512 + dstIndex] = value;
                }
            }
            return control_tensor;

            // const data = imgData.data;

            // const rows = imgData.height;
            // const cols = imgData.width;

            // let control_tensor = new Float32Array(3 * 512 * 512);
            // for (let i = 0; i < rows; i++) {
            //     for (let j = 0; j < cols; j++) {
            //         let dstIndex = i * cols + j;
            //         let value = data[4 * dstIndex + 3] / 255.0;
            //         control_tensor[0 * 512 * 512 + dstIndex] = value;
            //         control_tensor[1 * 512 * 512 + dstIndex] = value;
            //         control_tensor[2 * 512 * 512 + dstIndex] = value;
            //     }
            // }
            // return control_tensor;
        }

        function getSafeTensorName(modelVariant) {
            if (modelVariant == "canedge") {
                return "./net_canny.safetensors";
            }
            else if (modelVariant == "scribble") {
                return "./net_scribble.safetensors";
            }
        }
 
        window.addEventListener('load', async function () {
            if (!navigator.gpu) {
                document.getElementById("wgpuError").style.display = "";
                document.getElementById("sdTitle").style.display = "none";
                return;
            }

            let db = await initDb();

            const ctx = document.getElementById("canvas").getContext("2d", { willReadFrequently: true });

            document.addEventListener('mousedown', startPainting);
            document.addEventListener('mouseup', stopPainting);
            document.addEventListener('mousemove', sketch);

            function runStableDiffusion(control_tensor, prompt, steps, guidance, conditioning_scale) {
                return new Promise(async (resolve, reject) => {

                    let context = await timer(() => nets["textModel"](clipTokenizer.encodeForCLIP(prompt)));
                    let unconditional_context = await timer(() => nets["textModel"](clipTokenizer.encodeForCLIP("")));

                    let timesteps = [];

                    for (let i = 1; i < 1000; i += (1000 / steps)) {
                        timesteps.push(i);
                    }

                    console.log("Timesteps: " + timesteps);

                    const alphaCumprods = await readRangeFromFile(
                        safetensorsName,
                        metadata['alphas_cumprod']['data_offsets'][0] + 8 + metadataLength,
                        metadata['alphas_cumprod']['data_offsets'][1] + 8 + metadataLength);
                    let alphasCumprod = new Float32Array(alphaCumprods.buffer);

                    let alphas = [];

                    for (t of timesteps) {
                        alphas.push(alphasCumprod[Math.floor(t)]);
                    }

                    alphas_prev = [1.0];

                    for (let i = 0; i < alphas.length - 1; i++) {
                        alphas_prev.push(alphas[i]);
                    }

                    let inpSize = 4 * 64 * 64;
                    latent = new Float32Array(inpSize);

                    for (let i = 0; i < inpSize; i++) {
                        latent[i] = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());
                    }

                    for (let i = timesteps.length - 1; i >= 0; i--) {
                        let timestep = new Float32Array([timesteps[i]]);
                        let x_prev = await timer(() => nets["diffusor"](
                            control_tensor,
                            unconditional_context,
                            context,
                            latent,
                            timestep,
                            new Float32Array([alphas[i]]),
                            new Float32Array([alphas_prev[i]]),
                            new Float32Array([guidance]),
                            new Float32Array([conditioning_scale]),
                        ));
                        latent = x_prev;
                        document.getElementById("progressBar").value = ((steps - i) / steps) * 100
                        document.getElementById("progressFraction").innerHTML = (steps - i) + "/" + steps
                    }

                    resolve(await timer(() => nets["decoder"](latent)));
                });
            }

            document.getElementById("btnRunNet").addEventListener("click", function (e) {
                e.target.disabled = true;

                document.getElementById('inputCanvas')

                const controlTensor = getControlTensor(document.getElementById("constraintSelect").value);

                runStableDiffusion(controlTensor, document.getElementById("promptText").value, document.getElementById("stepRange").value, document.getElementById("guidanceRange").value, document.getElementById("conditioningScale").value).then((image) => {
                    let pixels = []
                    let pixelCounter = 0

                    for (let j = 0; j < 512; j++) {
                        for (let k = 0; k < 512; k++) {
                            pixels.push(image[pixelCounter])
                            pixels.push(image[pixelCounter + 1])
                            pixels.push(image[pixelCounter + 2])
                            pixels.push(255)
                            pixelCounter += 3
                        }
                    }

                    ctx.putImageData(new ImageData(new Uint8ClampedArray(pixels), 512, 512), 0, 0);
                    console.log(image);
                    console.log("Success");
                    e.target.disabled = false;
                });
            }, false);

            const stepSlider = document.getElementById('stepRange');
            const stepValue = document.getElementById('stepValue');

            stepSlider.addEventListener('input', function () {
                stepValue.textContent = stepSlider.value;
            });

            const guidanceSlider = document.getElementById('guidanceRange');
            const guidanceValue = document.getElementById('guidanceValue');

            guidanceSlider.addEventListener('input', function () {
                guidanceValue.textContent = guidanceSlider.value;
            });

        });

        const loadNet = async (modelVariant) => {
            const modelDlTitle = document.getElementById("modelDlTitle");

            const progress = (loaded, total) => {
                document.getElementById("modelDlProgressBar").value = (loaded / total) * 100
                document.getElementById("modelDlProgressValue").innerHTML = Math.trunc((loaded / total) * 100) + "%"
            }

            const device = await getDevice();

            let models = ["textModel", "diffusor", "decoder"];

            safetensorsName = getSafeTensorName(modelVariant);
            metadataLength = await getMetadataLength(safetensorsName);
            metadata = await getMetadata(safetensorsName, metadataLength);
            console.log("Metadata: " + JSON.stringify(metadata));


            nets = await timer(() => Promise.all([
                textModel().setup(device, safetensorsName, metadata, metadataLength),
                diffusor().setup(device, safetensorsName, metadata, metadataLength),
                decoder().setup(device, safetensorsName, metadata, metadataLength)
            ]).then((loadedModels) => loadedModels.reduce((acc, model, index) => { acc[models[index]] = model; return acc; }, {})), "(compilation)")

            progress(1, 1);

            modelDlTitle.innerHTML = "Model ready"
            setTimeout(() => {
                document.getElementById("modelDlProgressBar").style.display = "none";
                document.getElementById("modelDlProgressValue").style.display = "none";
                document.getElementById("divStepProgress").style.display = "flex";
            }, 1000);
            document.getElementById("btnRunNet").disabled = false;
        }

        //after selecting model variant, load the model, enable all other options
        function modelSelect() {
            const modelVariant = document.getElementById("constraintSelect").value;
            loadNet(modelVariant);
            document.getElementById("promptText").disabled = false;
            document.getElementById("stepRange").disabled = false;
            document.getElementById("guidanceRange").disabled = false;
            document.getElementById("conditioningScale").disabled = false;

                //model variant specific options
                if (modelVariant == "canedge") {
                    document.getElementById("imageUpload").hidden = false;
                    // make clear button for scribble invisible
                    document.getElementById("clear").hidden = true;
                    clearCanvas();
                }
                else if (modelVariant == "scribble") {
                    //make constraint image upload invisible
                    document.getElementById("imageUpload").hidden = true;
                    //visible button
                    document.getElementById("clear").hidden = false;
                }
            }

            //model select handler on change
            document.getElementById("constraintSelect").addEventListener("change", modelSelect);

            //use preview canvas as drawing canvas
            //adapted from https://www.geeksforgeeks.org/how-to-draw-with-mouse-in-html-5-canvas/
            var inputCanvas = document.getElementById('inputCanvas');
            const inputCtx = inputCanvas.getContext('2d');
            let coord = { x: 0, y: 0 };
            let paint = false;

            function getPosition(event) {
                coord.x = event.clientX - inputCanvas.offsetLeft;
                coord.y = event.clientY - inputCanvas.offsetTop + window.scrollY;
            }

            function startPainting(event) {
                paint = true;
                getPosition(event);
            }
            function stopPainting() {
                paint = false;
            }

            function sketch(event) {
                if (!paint || document.getElementById("constraintSelect").value != "scribble") return;
                inputCtx.beginPath();
                inputCtx.lineWidth = 7;
                inputCtx.lineCap = 'round';
                inputCtx.strokeStyle = 'black';

                inputCtx.moveTo(coord.x, coord.y);

                getPosition(event);

                inputCtx.lineTo(coord.x, coord.y);

                inputCtx.stroke();
            }

            function clearCanvas() {
                inputCtx.clearRect(0, 0, canvas.width, canvas.height);
            }

            var clear = document.getElementById("clear");
            clear.addEventListener("click", clearCanvas);
    </script>
</body>

</html>